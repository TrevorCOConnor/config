In the first example, we handle a thread by sharing variables with the thread. The thread has access to the name of the file and the content. Because we use the lazy byte string function, the thread simply does as much work as it can at any given time -- if there is data to compress in the content variable, it will compress it.

In the second example, we handle a thread by using a special type of variable for communicating between threads: `MVar`. This almost seems to work like an inbox of sorts. We create an empty instance of that variable, and start a thread that references it. At a later point, we put something into that object and that wakes the thread. It grabs the thing from that object, and acts accordingly. The part of this that really confuses me, though, is it seems like this is a mutuable object. It started empty and we updated it. I assume that what is really happening is that when we define the thread operations we are really defining a function that takes in MVars and does an IO action. The `putMVar` is then syntactic sugar for execute the function with `this` value. The reuse of the variable -- `m` in this case -- probably works more like an identifier: "run all of the functions created with the use of this variable."

Er... Maybe not... Because when I try to do multiple puts, only the first is noticed. We'll see what's to follow...
